{"title":"Agentic Coding - Copilot to Coworker","tags":["llm","programming"],"date":"2025-07-06","template":"post.mustache","CORK_url":"post/agentic-coding.html","CORK_reading_time":11,"CORK_lix_readability_score":36,"CORK_ari_readability_score":10,"content":"<p>For the past few months I've been playing around with various AI assisted coding tools. So far, <a href=\"https://cursor.com/\">Cursor</a> seems to be the tool with the most usage/ mindshare, and it has been my daily driver for the most part. Recently however, Cursor made some <a href=\"https://cursor.com/blog/june-2025-pricing\">interesting pricing choices</a> that have disgruntled their userbase<span class=\"mgnote\">It doesn't help that programmers are infamously easy to disgrunt</span>.\nAs such, there's been a lot of chatter amongst the vibe-coding cognoscenti as to alternatives. One such alternative which has come up relatively consistently is Anthropic's <a href=\"https://www.anthropic.com/claude-code\">Claude Code</a>. At first this was unsurprising, since I've always found Anthropic's models to be superior to the other foundational model providers when it comes to coding. Interestingly though, the general reception to Claude Code has been quite polarizing, with one camp singing its praises and treating it as the second coming, and the other quickly becoming apostates, trying it a few times and then proclaiming that it just &quot;isn't as good&quot;, and doesn't seem to &quot;get it&quot; (and then disheartendly slinking back to Cursor).</p>\n<p>This dynamic is particularly interesting because most of the people I've talked to who dislike Claude Code are regular users of Cursor and other LLM tooling, so they are familiar with how these tools theoretically work. I also know them to form intelligent opinions in general<span class=\"mgnote\">as opposed to the typical rabid genuflection at the alter of the latest LLM tooling by the general mass of AI-pilled &quot;devs&quot; on twitter</span>, and so was surprised that their experience differs from my own successful/ enjoyable usage of Claude Code. I'm on vacation, and so have had more time than usual to ruminate on things, and I think I've figured out what the disconnect here is.</p>\n<h2 id=\"copilots-vs-coworkers\">Copilots vs Coworkers</h2>\n<p>The core issue at hand, and why some devs are struggling to adopt tools like Claude Code is unrelated to the tool itself, and instead due to a mental model discrepancy. Fundamentally, Cursor saw its meteoric rise in adoption because it packaged up the power of LLM assisted coding into a UX that was already familiar to developers. They took an IDE and supercharged it. Sure, they have since added more agentic workflows, and recently <a href=\"https://docs.cursor.com/background-agent\">background agents</a>, but what made their bones was that they started with a coding tool devs were already comfortable with (autocomplete in an IDE), and sprinkled in some magic. As Cursor has continued to evolve, the paradigm has shifted towards devs &quot;coding&quot; in english, and it acting as a UI to transcribe that english into a computer language, but the primitives have remained the same... You see the diff of code changes, iterate on it as necessary, and are always in control of the process at a very granular level.</p>\n<p>If you've become comfortable with that way of operating, and are patting yourself on the back for <em>really being on the ball with this whole AI thing</em>, then using Claude Code can feel like a regression. That's because Claude Code is an instantiation of a truly &quot;agentic coding&quot; tool. Whereas Cursor fits the paradigm devs have used since the advent of IDEs, Claude Code (and other agentic coding tools) requires a mental model shift wherein you act as a manager responsible for an eager and smart, but sort of clueless junior dev. <strong>People that don't grok this difference will struggle to use Claude Code for the same reason that managers who don't know how to manage end up tanking team efficiency.</strong> Given the aversion a lot of devs I know have to management in general, it isn't surprising that crossing this chasm has been met with resistance. Regardless, <a href=\"https://www.youtube.com/watch?v=LCEmiRjPEtQ\">agentic tooling is the future</a>, so there's no choice but to get on board. The rest of this post is my attempt at a guide for how to do so.</p>\n<h2 id=\"from-micromanager-to-tech-lead\">From Micromanager to Tech Lead</h2>\n<p>It is a somewhat well established leadership doctrine that &quot;micromanaging&quot; your employees is bad. Instead, you want to hire smart people, and develop them such that they are capable of delivering the right things for your business without constant oversight. This doctrine applies equally to the world of agentic coding. The way people use Cursor, meticulously correcting diffs chunk by chunk, and iterating back and forth via the prompt sidebar is akin to micromanaging a new hire by grabbing their keyboard every few seconds to fix their code. You're catching the metaphorical fish for them instead of teaching. It's inefficient and frustrating for you, and doesn't leverage (or let them reach) their full potential.</p>\n<p>Instead, think about how an experienced tech lead teaches a junior dev. When a junior puts up a PR with issues, the tech lead doesn't just pull the branch, fix the code, and push it. That would solve the immediate problem, but practically guarantee that the junior will make the same mistake again. Instead, a great tech lead spends time explaining the <em>underlying principle</em> behind the required changes, touches on relevant best practices and architectural patterns where appropriate, and links to useful documentation, blog posts, etc. All of this is more work in the moment, but provides useful context that the junior can learn from in a more sustainable fashion, and levels them up over time.</p>\n<p><strong>This is precisely how we must interact with coding agents.</strong> With Claude Code, for example, it means that you stop touching the code it produces directly, and start teaching it how to write better code. Let that sink in: <strong>Don't manually edit the diffs</strong>. The core of this new workflow can be thought of as <a href=\"https://x.com/karpathy/status/1937902205765607626\">&quot;context engineering&quot;</a><span class=\"mgnote\">which is something of a buzzword at this point, similar to &quot;prompt engineering&quot;, but the underlying concept is key to getting good performance out of the models</span>. You need to give your AI agent the same onboarding packet you'd give a new employee. In Claude Code, this can be managed through files like <code>claude.md</code>, and Anthropic already provides <a href=\"https://www.anthropic.com/engineering/claude-code-best-practices\">mechanisms to scope the context as desired</a>. Furthermore, you must iterate on this context over time, teaching claude how to level up into the type of engineer you/ your company wants.</p>\n<p>Most devs that have embraced AI for coding know this abstractly, but haven't fully internalized it into their workflow. Instead of me trying to reinforce that learning, here's a few shots at examples that hopefully put things in context:</p>\n<p>Example 1:</p>\n<ul>\n<li><strong>DON'T:</strong> See that the agent used a magic string instead of a constant, so you edit the diff to fix it.</li>\n<li><strong>DO:</strong> Leave a code-review style comment to Claude Code like: &quot;Please refactor this to use the defined constants from <code>constants.ts</code> to avoid magic strings. Then, ensure your <code>claude.md</code> file has a rule explicitly stating: <code>Rule: Always use predefined constants for configuration values and event names. Avoid using raw strings ('magic strings') directly in the code.</code>&quot;</li>\n</ul>\n<p>Example 2:</p>\n<ul>\n<li><strong>DON'T:</strong> Manually fix a poorly formatted block of code.</li>\n<li><strong>DO:</strong> Give feedback like: &quot;This doesn't seem to follow our project's linting rules. Please run the linter and apply the necessary fixes. Then, update your context file to contain instructions on how to run and respect those tools such as: <code>All code must pass the ESLint check before being considered complete. Run 'pnpm run lint' and fix all errors.</code>&quot;</li>\n</ul>\n<p>Example 3:</p>\n<ul>\n<li><strong>DON'T:</strong> Move code the agent has implemented to a different spot or change the names and/or structure of things it creates.</li>\n<li><strong>DO:</strong> Give feedback that clarifies why the names or structure of the code written doesn't align with your expectations, and what general rules or heuristics are applicable to ensure that sort of mistake doesn't happen again. Tell Claude Code to reiterate the learning back to you, and then add a rule to the <code>claude.md</code> file when you're satisfied with its understanding.</li>\n</ul>\n<p>This is the <a href=\"https://ghuntley.com/stdlib/\">proper agentic loop</a>. When the agent gets it wrong, you don't fix the output; you clarify the instructions and improve the context. Then you ask it to try again. Trying again- instead of fixing almost working code- feels strange for devs used to treating code as a scarce good, but <a href=\"https://sourcegraph.com/blog/the-death-of-the-junior-developer\">code is a commodity now</a>, and our new AI coworkers never get tired, bored, or annoyed at being asked to redo a task.</p>\n<h2 id=\"compounding-returns\">Compounding Returns</h2>\n<p>Again, this <em>slows things down</em> at first, because teaching is harder than doing. What you learn as a tech lead, though, is that the benefits of scaling a dev team in this way very soon outweigh the cost of the initial slowdown. Add in the fact that LLMs don't need health insurance or vacations, and their brains operate in gigahertz, and the true return on investment starts to come into focus. With a human developer, this mentorship pays off over months and years. With an LLM agent, the iteration cycle is measured in <em>minutes</em>. After you add a rule to your context file, the agent <em>learns</em> it for the very next task. The quality of its output doesn't just get better; it stays better. You stop having to correct the same class of errors over and over again. Now, every time you improve the agent context, you are improving every single future junior dev. Additionally, scaling your team switches from being bottlenecked on hiring to being bottlenecked on compute.</p>\n<p>You can't clone your best senior developer who has spent five years internalizing your company's culture and codebase. But you <em>can</em> clone a well-mentored AI agent's configuration instantly. Once you have crafted a high quality context that produces idiomatic, compliant code, you can spin up ten or a hundred copies of that agent, limited only by your budget. You can build a scalable, effective development team that grows with your needs.</p>\n<h2 id=\"your-next-promotion-is-to-agent-manager\">Your Next Promotion is to &quot;Agent Manager&quot;</h2>\n<p>To recap:</p>\n<ol>\n<li><strong>A Paradigm Shift is Here:</strong> The turmoil in the AI coding tool space is accelerating a necessary shift from &quot;copilot&quot; models (better autocomplete) to &quot;agentic&quot; models (digital coworkers).</li>\n<li><strong>Stop Micromanaging, Start Managing:</strong> Success with tools like Claude Code hinges on changing your mindset. Stop editing diffs directly and start providing high-level, code-review-style feedback.</li>\n<li><strong>Context is King:</strong> Your primary job becomes &quot;context engineering.&quot; Build and maintain a comprehensive set of instructions, rules, and best practices that your AI agent can use as its source of truth.</li>\n<li><strong>Embrace the Loop:</strong> The workflow is: <strong>Task -&gt; Review -&gt; Feedback -&gt; Update Context -&gt; Retry.</strong> This creates a compounding effect where the agent's capabilities continuously improve.</li>\n<li><strong>The Future is Scalable:</strong> Mastering this agentic workflow isn't just about using a new tool effectively; it's about learning a skill that will define the next generation of software development- the ability to manage and scale a team of AI developers.</li>\n</ol>\n<p>The developers who are lamenting that tools like Claude Code &quot;aren't as good&quot; to <em>use</em> are likely actually running into gaps in their ability to <em>teach</em>. Cursor, and other IDE based AI tools were easy to adopt because they provide escape valves to cover up that teaching deficiency, but the future of AI assisted coding is increasingly autonomous agents, and micromanaging them won't scale for all the same reasons that micromanaging humans doesn't scale.</p>\n<p>This will be a hard pill for some software developers to swallow. Until recently I wrote software used regularly by <a href=\"https://pharmacy.amazon.com/\">pharmacists</a>, and so found this <a href=\"https://sourcegraph.com/blog/the-death-of-the-stubborn-developer\">Steve Yegge quote</a> particularly pertinent to the situation:</p>\n<blockquote>\n<p>Pharmacists have told me that a lot of patients are confused about their suppository meds and try to eat them. I think that is such a beautiful metaphor here. [Agentic coding] is unintuitive, biased towards hotshots, nonuniform in its productivity boosts, not yet well-supported by tools, and hard to measure. And you shouldn't eat it.</p>\n</blockquote>\n<p>It's up to you to decide what you <em>should</em> do with it to ensure you're maximizing its value.</p>\n"}