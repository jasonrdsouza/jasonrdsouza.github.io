{"title":"Homelab Server Setup","tags":["homelab","caddy"],"date":"2020-01-11","template":"post.mustache","CORK_url":"post/homelab-server.html","CORK_reading_time":8,"CORK_lix_readability_score":34,"CORK_ari_readability_score":8,"content":"<h2 id=\"background\">Background</h2>\n<p>I recently decided to set up a new server for my <a href=\"https://www.reddit.com/r/homelab/\">homelab</a>. Unlike my other home servers, which are only accessible over the local network, I wanted this one to be available to the wider internet, with specific services visible on subdomains of a domain I own (<code>dsouza.io</code>). I knew this required a reverse proxy like <a href=\"https://www.nginx.com/\">Nginx</a> or <a href=\"https://caddyserver.com/\">Caddy</a>, but wasn't sure of the exact steps needed. What follows is a lightly edited version of the notes I took along the way to figuring it out.</p>\n<h2 id=\"dynamic-dns\">Dynamic DNS</h2>\n<p>Since I use a residential ISP, my home IP address is subject to change over time, so to ensure that a domain name continues to resolve to my home server, I needed to set up <a href=\"https://en.wikipedia.org/wiki/Dynamic_DNS\">Dynamic DNS</a>. This basically involves installing software on your server that communicates with your domain name provider and periodically refreshes the IP address that the domain name provides associates with your domain name.</p>\n<p>Most providers make it relatively easy to enable Dynamic DNS. In my case, I use <a href=\"https://domains.google.com/registrar\">Google Domains</a>, and they provide <a href=\"https://support.google.com/domains/answer/6147083?hl=en\">simple instructions</a> for enabling it.</p>\n<p>I chose to set up <a href=\"https://home.dsouza.io\"><code>home.dsouza.io</code></a> to dynamically point to my residential IP.</p>\n<h2 id=\"cnames\">CNAMEs</h2>\n<p>Since I host most of my services on AppEngine, Google Cloud, or Github, I've only ever had to follow their instructions and create DNS records to point to their servers, and never really spent the time to understand how things work under the hood. Doing it myself made me realize that a <a href=\"https://en.wikipedia.org/wiki/CNAME_record\">CNAME record</a> simply allows you to point one (sub)domain name to another, allowing you to redirect requests for multiple domains all to the same IP address (and subsequently the same server).</p>\n<p>This is useful if you have multiple distinct services running on a single server (or really, behind a single IP address), and want them to each have their own subdomain. In my case, for example, I have a personal wiki service running on the same box as the webserver serving <a href=\"https://home.dsouza.io\"><code>home.dsouza.io</code></a>, but wanted the wiki accessible from <a href=\"https://wiki.dsouza.io\"><code>wiki.dsouza.io</code></a>. CNAME records make this possible.</p>\n<p>Once you have the records set up, you can check that the domain names are resolving as expected with the <a href=\"https://en.wikipedia.org/wiki/Dig_(command)\">dig</a> command line tool. For example:</p>\n<pre><code class=\"language-bash\">jason@dsouza-laptop ~&gt; dig wiki.dsouza.io\n\n; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; wiki.dsouza.io\n;; global options: +cmd\n;; Got answer:\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 8343\n;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 512\n;; QUESTION SECTION:\n;wiki.dsouza.io.\t\t\tIN\tA\n\n;; ANSWER SECTION:\nwiki.dsouza.io.\t\t3599\tIN\tCNAME\thome.dsouza.io.\nhome.dsouza.io.\t\t59\tIN\tA\t108.20.205.69\n\n;; Query time: 177 msec\n;; SERVER: 192.168.86.1#53(192.168.86.1)\n;; WHEN: Mon Jan 11 21:08:26 EST 2021\n;; MSG SIZE  rcvd: 78\n</code></pre>\n<p>In this case, you can see that <a href=\"https://wiki.dsouza.io\"><code>wiki.dsouza.io</code></a> points to <a href=\"https://home.dsouza.io\"><code>home.dsouza.io</code></a>, which in turn points to my home server.</p>\n<h2 id=\"port-forwarding\">Port Forwarding</h2>\n<p>With Dynamic DNS enabled, requests to your domain name will resolve to your IP address, but that doesn't mean that they will automatically be able to hit your home server. Most routers have a firewall to disallow incoming traffic. This is a good thing, since the majority of users don't intend to expose any services to the wider internet, but in our case, we need to enable incoming traffic to hit our server. To do that, we can open up specific ports on the routers' firewall and send the traffic that reaches them to a chosen machine running on our local network. This process is colloquially referred to as &quot;<a href=\"https://en.wikipedia.org/wiki/Port_forwarding\">port forwarding</a>&quot;.</p>\n<p>Unless you need to expose services on non-standard ports, you likely only want to forward the standard http ports (<code>80</code> for regular traffic, and <code>443</code> for TLS traffic). They should be forwarded to the local IP address of the machine you're running your reverse proxy on, with any further routing decisions performed by the reverse proxy itself.</p>\n<p><em>Note that some routers can themselves run a reverse proxy, allowing you to contain all the routing logic to the router itself.</em></p>\n<h2 id=\"local-firewall\">Local Firewall</h2>\n<p>In addition to the router firewall, you're server itself may be running a firewall. <a href=\"https://wiki.ubuntu.com/UncomplicatedFirewall\">UFW</a> is a common firewall frontend for Ubuntu installs, but depending on what OS you're running, something else may be used. Regardless, you'll have to ensure that (at the very least) ports <code>80</code> and <code>443</code> are unblocked here as well. If you plan to SSH into your server, you'll want to unblock the port you use for that as well.</p>\n<p>A minimal sample of useful UFW commands:</p>\n<pre><code class=\"language-bash\">jason@dsouza-server:~$ sudo ufw status # show which ports are currently open\njason@dsouza-server:~$ sudo ufw allow http # allow http traffic\njason@dsouza-server:~$ sudo ufw allow https # allow https traffic\njason@dsouza-server:~$ sudo ufw disable # if things aren't working, you can try temporarily disabling the firewall\njason@dsouza-server:~$ sudo ufw enable # just make sure to enable it again once you figure out the issue\n</code></pre>\n<h2 id=\"reverse-proxying\">Reverse Proxying</h2>\n<p>With that in place, requests from both <a href=\"https://wiki.dsouza.io\"><code>wiki.dsouza.io</code></a> and <a href=\"https://home.dsouza.io\"><code>home.dsouza.io</code></a> (and any other domains I wish to set up CNAME records for) will reach my server. Then, with a reverse proxy, I can direct those requests to the appropriate local services. The services will be running on the local loopback address of my server, each with a distinct associated port. The reverse proxy is what knows how to translate a given domain into a local port so that the appropriate service handles a request.</p>\n<h3 id=\"caddy-example\">Caddy Example</h3>\n<p>On my server, I'm using Caddy, and the relevant sections of the Caddyfile look as follows:</p>\n<pre><code class=\"language-caddy\">home.dsouza.io {\n  # Set this path to your site's directory.\n  root * /var/www/html\n\n  # Enable the static file server.\n  file_server\n\n  # Other directives omitted for brevity\n  ...\n}\n\nperf.dsouza.io {\n  reverse_proxy localhost:61208\n\n  # Other directives omitted for brevity\n  ...\n}\n\nwiki.dsouza.io {\n  reverse_proxy localhost:4567\n\n  # Other directives omitted for brevity\n  ...\n}\n</code></pre>\n<h3 id=\"nginx-example\">NGINX Example</h3>\n<p>A friend of mine has a more extensive homelab, with many more services running, and uses NGINX. His config file looks something like:</p>\n<pre><code class=\"language-nginx\">server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    root /var/www/html;\n\n    # Add index.php to the list if you are using PHP\n    index index.html index.htm index.nginx-debian.html;\n\n    server_name _;\n\n    location / {\n        # First attempt to serve request as file, then\n        # as directory, then fall back to displaying a 404.\n        try_files $uri $uri/ =404;\n    }\n}\n\n# WWW\nserver {\n    if ($host = www.mattwilliams.cloud) {\n        return 301 https://$host$request_uri;\n    } # managed by Certbot\n\n    listen 80;\n    server_name www.mattwilliams.cloud;\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:80;\n        proxy_redirect off;\n    }\n}\nserver {\n    listen 443;\n    server_name www.mattwilliams.cloud;\n    ssl_certificate /etc/letsencrypt/live/books.mattwilliams.cloud/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/books.mattwilliams.cloud/privkey.pem; # managed by Certbot\n\n    root /var/www/html;\n    index index.html index.htm index.nginx-debian.html;\n    location / {\n    # First attempt to serve request as file, then\n    # as directory, then fall back to displaying a 404.\n    try_files $uri $uri/ =404;\n    }\n\n}\n\n# NextCloud\nserver {\n    listen 80;\n    server_name next.mattwilliams.cloud;\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:81;\n        proxy_redirect off;\n    }\n}\nserver {\n    listen 443;\n    server_name next.mattwilliams.cloud;\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass https://127.0.0.1:444;\n        proxy_redirect off;\n    }\n}\n\n# Calibre\nserver {\n    if ($host = books.mattwilliams.cloud) {\n        return 301 https://$host$request_uri;\n    } # managed by Certbot\n\n    listen 80;\n    server_name books.mattwilliams.cloud;\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:8080;\n        proxy_redirect off;\n    }\n}\nserver {\n    listen 443;\n    server_name books.mattwilliams.cloud;\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:8080;\n        proxy_redirect off;\n    }\n    ssl_certificate /etc/letsencrypt/live/books.mattwilliams.cloud/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/books.mattwilliams.cloud/privkey.pem; # managed by Certbot\n\n}\n\n# Glances System Monitor\nserver {\n    if ($host = perf.mattwilliams.cloud) {\n        return 301 https://$host$request_uri;\n    } # managed by Certbot\n\n    listen 80;\n    server_name perf.mattwilliams.cloud;\n\n    auth_basic           &quot;Administrator's Area&quot;;\n    auth_basic_user_file /etc/apache2/.htpasswd;\n\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:61208;\n        proxy_redirect off;\n    }\n}\nserver {\n    listen 443;\n    server_name perf.mattwilliams.cloud;\n\n    auth_basic           &quot;Administrator's Area&quot;;\n    auth_basic_user_file /etc/apache2/.htpasswd;\n\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:61208;\n        proxy_redirect off;\n    }\n    ssl_certificate /etc/letsencrypt/live/books.mattwilliams.cloud/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/books.mattwilliams.cloud/privkey.pem; # managed by Certbot\n\n}\n\n... many more services omitted\n</code></pre>\n<p>Both follow a similar pattern of redirecting a subdomain request to a locally running service. This is where the &quot;reverse proxy&quot; name comes from, because unlike a &quot;regular&quot; proxy, which a user goes through in order to access the wider internet, a reverse proxy fronts web accessible resources, serving them at a clients request.</p>\n<h2 id=\"success\">Success</h2>\n<p>And with that, navigating to <a href=\"https://home.dsouza.io\"><code>home.dsouza.io</code></a> resolves to the new box in my house and displays a landing page served by Caddy, and <a href=\"https://wiki.dsouza.io\"><code>wiki.dsouza.io</code></a> directs clients to the wiki software I have running!</p>\n"}