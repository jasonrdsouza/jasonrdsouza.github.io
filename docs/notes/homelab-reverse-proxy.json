{"title":"Homelab Reverse Proxy","tags":["nginx","caddy"],"date":"2020-01-11","template":"note.mustache","CORK_url":"notes/homelab-reverse-proxy.html","CORK_reading_time":8,"content":"<h2 id=\"background\">Background</h2>\n<p>I recently set up a reverse proxy for my <a href=\"https://www.reddit.com/r/homelab/\">homelab</a>, and one of the things I wanted to do was enable subdomains of a domain I own (<code>dsouza.io</code>) to point at distinct services that I host. I knew this required a reverse proxy like <a href=\"https://www.nginx.com/\">Nginx</a> or <a href=\"https://caddyserver.com/\">Caddy</a>, but wasn't sure of the exact steps required. What follows is a lightly edited version of the notes I took along the way to figuring it out.</p>\n<h2 id=\"cnames\">CNAMEs</h2>\n<p>Since I host most of my services on AppEngine, Google Cloud, or Github, I've only ever had to follow their instructions and create CNAME records to point to their servers, and never really spent the time to understand how things work under the hood. Doing it myself made me realize that a CNAME record simply allows you to point one (sub)domain name to another, allowing you to redirect requests for multiple domains all to the same IP address (and subsequently the same server).</p>\n<p>Once you have that set up, you can check that the domain names are resolving as expected with the <a href=\"https://en.wikipedia.org/wiki/Dig_(command)\">dig</a> command line tool. For example:</p>\n<pre><code class=\"language-bash\">jason@dsouza-laptop ~&gt; dig wiki.dsouza.io\n\n; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; wiki.dsouza.io\n;; global options: +cmd\n;; Got answer:\n;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 8343\n;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1\n\n;; OPT PSEUDOSECTION:\n; EDNS: version: 0, flags:; udp: 512\n;; QUESTION SECTION:\n;wiki.dsouza.io.\t\t\tIN\tA\n\n;; ANSWER SECTION:\nwiki.dsouza.io.\t\t3599\tIN\tCNAME\thome.dsouza.io.\nhome.dsouza.io.\t\t59\tIN\tA\t108.20.205.69\n\n;; Query time: 177 msec\n;; SERVER: 192.168.86.1#53(192.168.86.1)\n;; WHEN: Mon Jan 11 21:08:26 EST 2021\n;; MSG SIZE  rcvd: 78\n</code></pre>\n<p>In this case, you can see that <a href=\"https://wiki.dsouza.io\"><code>wiki.dsouza.io</code></a> points to <a href=\"https://home.dsouza.io\"><code>home.dsouza.io</code></a>, which in turn points to my home server.</p>\n<h2 id=\"dynamic-dns\">Dynamic DNS</h2>\n<p>Since I use a residential ISP, my home IP address is subject to change over time, so to ensure that the domain name continues to resolve to my home server, I needed to set up <a href=\"https://en.wikipedia.org/wiki/Dynamic_DNS\">Dynamic DNS</a>. This basically involves installing software on your server that communicates with your domain name provider and periodically refreshes the IP address that the domain name provides associates with your domain name.</p>\n<p>Most providers make it relatively easy to enable Dynamic DNS. In my case, I use <a href=\"https://domains.google.com/registrar\">Google Domains</a>, and they provide <a href=\"https://support.google.com/domains/answer/6147083?hl=en\">simple instructions</a> for enabling it.</p>\n<h2 id=\"port-forwarding\">Port Forwarding</h2>\n<p>With Dynamic DNS enabled, requests to your domain name will resolve to your IP address, but that doesn't mean that they will automatically be able to hit your home server. Most routers have a firewall to disallow incoming traffic. This is a good thing, since the majority of users don't intend to expose any services to the wider internet, but in our case, we need to enable incoming traffic to hit our server. To do that, we can open up specific ports on the routers firewall and send the traffic that reaches them to a specific machine running on our local network. This process is colloquially referred to as \"port forwarding\".</p>\n<p>Unless you need to expose services on non-standard ports, you likely only want to forward the standard http ports (<code>80</code> for regular traffic, and <code>443</code> for TLS traffic). They should be forwarded to the local IP address of the machine you're running your reverse proxy on, with any further routing decisions performed by the reverse proxy itself.</p>\n<p><em>Note that some routers can themselves run a reverse proxy, allowing you to contain all the routing logic to the router itself.</em></p>\n<h2 id=\"local-firewall\">Local Firewall</h2>\n<p>In addition to the router firewall, you're server itself may be running a firewall. <a href=\"https://wiki.ubuntu.com/UncomplicatedFirewall\">UFW</a> is a common firewall frontend for Ubuntu installs, but depending on what OS you're running, something else may be used. Regardless, you'll have to ensure that (at the very least) ports <code>80</code> and <code>443</code> are unblocked here as well. If you plan to SSH into your server, you'll want to unblock the port you use for that as well.</p>\n<p>A minimal sample of useful UFW commands:</p>\n<pre><code class=\"language-bash\">jason@dsouza-server:~$ sudo ufw status # show which ports are currently open\njason@dsouza-server:~$ sudo ufw allow http # allow http traffic\njason@dsouza-server:~$ sudo ufw allow https # allow https traffic\njason@dsouza-server:~$ sudo ufw disable # if things aren't working, you can try temporarily disabling the firewall\njason@dsouza-server:~$ sudo ufw enable # just make sure to enable it again once you figure out the issue\n</code></pre>\n<h2 id=\"reverse-proxying\">Reverse Proxying</h2>\n<p>With that in place, requests from both <code>wiki.dsouza.io</code> and <code>home.dsouza.io</code> (and any other domains I wish to set up CNAME records for) will reach my server. Then, with a reverse proxy, I can direct those requests to the appropriate services. The services will be running on the local loopback address of my server, each with a distinct associated port. The reverse proxy is what knows how to translate a given domain into a local port so that the appropriate service handles a request.</p>\n<h3 id=\"caddy-example\">Caddy Example</h3>\n<p>On my server, I'm using Caddy, and the relevant sections of the Caddyfile look as follows:</p>\n<pre><code class=\"language-caddy\">home.dsouza.io {\n  # Set this path to your site's directory.\n  root * /var/www/html\n\n  # Enable the static file server.\n  file_server\n\n  # Other directives omitted for brevity\n  ...\n}\n\nperf.dsouza.io {\n  reverse_proxy localhost:61208\n\n  # Other directives omitted for brevity\n  ...\n}\n\nwiki.dsouza.io {\n  reverse_proxy localhost:4567\n\n  # Other directives omitted for brevity\n  ...\n}\n</code></pre>\n<h3 id=\"nginx-example\">NGINX Example</h3>\n<p>A friend of mine has a more extensive homelab, with many more services running, and uses NGINX. His config file looks something like:</p>\n<pre><code class=\"language-nginx\">server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    root /var/www/html;\n\n    # Add index.php to the list if you are using PHP\n    index index.html index.htm index.nginx-debian.html;\n\n    server_name _;\n\n    location / {\n        # First attempt to serve request as file, then\n        # as directory, then fall back to displaying a 404.\n        try_files $uri $uri/ =404;\n    }\n}\n\n# WWW\nserver {\n    if ($host = www.mattwilliams.cloud) {\n        return 301 https://$host$request_uri;\n    } # managed by Certbot\n\n    listen 80;\n    server_name www.mattwilliams.cloud;\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:80;\n        proxy_redirect off;\n    }\n}\nserver {\n    listen 443;\n    server_name www.mattwilliams.cloud;\n    ssl_certificate /etc/letsencrypt/live/books.mattwilliams.cloud/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/books.mattwilliams.cloud/privkey.pem; # managed by Certbot\n\n    root /var/www/html;\n    index index.html index.htm index.nginx-debian.html;\n    location / {\n    # First attempt to serve request as file, then\n    # as directory, then fall back to displaying a 404.\n    try_files $uri $uri/ =404;\n    }\n\n}\n\n# NextCloud\nserver {\n    listen 80;\n    server_name next.mattwilliams.cloud;\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:81;\n        proxy_redirect off;\n    }\n}\nserver {\n    listen 443;\n    server_name next.mattwilliams.cloud;\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass https://127.0.0.1:444;\n        proxy_redirect off;\n    }\n}\n\n# Calibre\nserver {\n    if ($host = books.mattwilliams.cloud) {\n        return 301 https://$host$request_uri;\n    } # managed by Certbot\n\n    listen 80;\n    server_name books.mattwilliams.cloud;\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:8080;\n        proxy_redirect off;\n    }\n}\nserver {\n    listen 443;\n    server_name books.mattwilliams.cloud;\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:8080;\n        proxy_redirect off;\n    }\n    ssl_certificate /etc/letsencrypt/live/books.mattwilliams.cloud/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/books.mattwilliams.cloud/privkey.pem; # managed by Certbot\n\n}\n\n# Glances System Monitor\nserver {\n    if ($host = perf.mattwilliams.cloud) {\n        return 301 https://$host$request_uri;\n    } # managed by Certbot\n\n    listen 80;\n    server_name perf.mattwilliams.cloud;\n\n    auth_basic           \"Administrator's Area\";\n    auth_basic_user_file /etc/apache2/.htpasswd;\n\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:61208;\n        proxy_redirect off;\n    }\n}\nserver {\n    listen 443;\n    server_name perf.mattwilliams.cloud;\n\n    auth_basic           \"Administrator's Area\";\n    auth_basic_user_file /etc/apache2/.htpasswd;\n\n    location / {\n        proxy_set_header Host $host;\n        proxy_pass http://127.0.0.1:61208;\n        proxy_redirect off;\n    }\n    ssl_certificate /etc/letsencrypt/live/books.mattwilliams.cloud/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/books.mattwilliams.cloud/privkey.pem; # managed by Certbot\n\n}\n\n... many more services omitted\n</code></pre>\n<p>Both follow a similar pattern of redirecting a subdomain request to a locally running service. This is where the \"reverse proxy\" name comes from, because unlike a \"regular\" proxy, which a user goes through in order to access the wider internet, a reverse proxy fronts web accessible resources, serving them at a clients request.</p>\n<h2 id=\"auth\">Auth</h2>\n<p><em>... todo explainer and setup guide</em></p>\n"}